# Form API Reference

Complete reference for all methods and properties available on the form instance returned by `useForm`.

## Form Instance Methods

### `getFormValues()`

Returns all current form values for registered fields.

**Returns:** `Partial<T>` - Object containing current values of all registered fields

```tsx
const form = useForm<{ name: string; email: string }>();
const values = form.getFormValues();
// Returns: { name?: string, email?: string }
```

**Example:**
```tsx
function FormDebugger() {
  const form = useFormContext<UserForm>();
  
  const showCurrentValues = () => {
    const values = form.getFormValues();
    console.log('Current form values:', values);
  };

  return <button onClick={showCurrentValues}>Show Values</button>;
}
```

### `setFormValues(values)`

Updates one or more form field values programmatically.

**Parameters:**
- `values: Partial<T>` - Object containing field values to update

**Returns:** `void`

```tsx
form.setFormValues({ 
  name: 'John Doe', 
  email: 'john@example.com' 
});
```

**Example:**
```tsx
function FormPresetter() {
  const form = useFormContext<UserForm>();
  
  const presetUserData = () => {
    form.setFormValues({
      name: 'Demo User',
      email: 'demo@example.com',
      role: 'admin'
    });
  };

  return <button onClick={presetUserData}>Load Demo Data</button>;
}
```

**Notes:**
- If a field is not registered yet, the value will be stored and applied when the field is registered
- Triggers re-renders for components watching the updated fields
- Values are merged with existing form data (not replaced)

### `resetForm()`

Resets all form fields to `undefined`.

**Returns:** `void`

```tsx
form.resetForm();
```

**Example:**
```tsx
function FormControls() {
  const form = useFormContext<UserForm>();
  
  const handleReset = () => {
    if (confirm('Are you sure you want to reset the form?')) {
      form.resetForm();
    }
  };

  return (
    <div>
      <button type="button" onClick={handleReset}>
        Reset Form
      </button>
    </div>
  );
}
```

**Notes:**
- Clears all field values but doesn't reset validation states
- Triggers re-renders for all components watching form values
- Fields remain registered after reset

### `handleSubmit(callback)`

Creates a submit handler function for your form.

**Parameters:**
- `callback: (formValues: T) => void | Promise<void>` - Function called with form data when submitted

**Returns:** `() => void` - Submit handler function to use with form `onSubmit`

```tsx
const handleSubmit = form.handleSubmit(async (formData) => {
  // formData contains all form values
  await saveUser(formData);
});

// Use with form element
<form onSubmit={handleSubmit}>
  {/* Form content */}
</form>
```

**Example:**
```tsx
function UserForm() {
  const form = useForm<UserFormData>();

  const handleSubmit = form.handleSubmit(async (data) => {
    try {
      setLoading(true);
      await api.createUser(data);
      toast.success('User created successfully!');
      form.resetForm();
    } catch (error) {
      toast.error('Failed to create user');
    } finally {
      setLoading(false);
    }
  });

  return (
    <form onSubmit={handleSubmit}>
      <Form form={form}>
        {/* Fields */}
        <button type="submit" disabled={loading}>
          {loading ? 'Creating...' : 'Create User'}
        </button>
      </Form>
    </form>
  );
}
```

## useForm Configuration Options

### `defaultValues`

Sets initial values for form fields.

**Type:** `Partial<T> | (() => Partial<T>)`

```tsx
// Static default values
const form = useForm<UserForm>({
  defaultValues: {
    name: 'John Doe',
    email: 'john@example.com',
    role: 'user'
  }
});

// Dynamic default values
const form = useForm<UserForm>({
  defaultValues: () => ({
    name: user?.name || '',
    email: user?.email || '',
    timestamp: Date.now(),
    theme: localStorage.getItem('theme') || 'light'
  })
});
```

**Examples:**

**Loading user data:**
```tsx
function EditUserForm({ userId }: { userId: string }) {
  const { data: user } = useQuery(['user', userId], () => fetchUser(userId));
  
  const form = useForm<UserForm>({
    defaultValues: () => ({
      name: user?.name || '',
      email: user?.email || '',
      role: user?.role || 'user'
    })
  });
  
  // Form will automatically populate when user data loads
}
```

**Environment-based defaults:**
```tsx
const form = useForm<AppSettings>({
  defaultValues: () => ({
    apiUrl: process.env.NODE_ENV === 'development' 
      ? 'http://localhost:3000/api' 
      : 'https://api.example.com',
    debugMode: process.env.NODE_ENV === 'development',
    theme: localStorage.getItem('preferred-theme') || 'light'
  })
});
```

### `onUpdateAfterBlur`

Callback executed when a field loses focus after being updated and is valid.

**Type:** `<K extends keyof T>(name: K, value: T[K] | undefined, data: AnyRecord, formPartial: FormPartial<T>) => Promise<void> | void`

**Parameters:**
- `name` - Field name that was updated
- `value` - New field value
- `data` - Additional data from the field's blur event
- `formPartial` - Object with form methods: `{ getFormValues, setFormValues, resetForm }`

**Triggers when:**
- Field had user focus (was actively edited)
- Field passes validation (status is VALID)
- Field loses focus (onBlur event)

```tsx
const form = useForm<FormData>({
  onUpdateAfterBlur: async (fieldName, value, data, { getFormValues, setFormValues }) => {
    // Auto-save functionality
    if (fieldName === 'title' && value) {
      await saveFormDraft(getFormValues());
    }
    
    // Auto-populate related fields
    if (fieldName === 'zipCode' && value) {
      const cityInfo = await fetchCityByZip(value);
      if (cityInfo) {
        setFormValues({
          city: cityInfo.city,
          state: cityInfo.state
        });
      }
    }
    
    // Validate dependent fields
    if (fieldName === 'password') {
      // Revalidate password confirmation
      const currentValues = getFormValues();
      if (currentValues.confirmPassword) {
        // Trigger revalidation of confirm password field
      }
    }
  }
});
```

**Real-world examples:**

**Auto-save draft:**
```tsx
const form = useForm<ArticleForm>({
  onUpdateAfterBlur: async (fieldName, value, data, { getFormValues }) => {
    // Auto-save after any field is updated
    const currentValues = getFormValues();
    
    // Debounce the save to avoid too many requests
    clearTimeout(autoSaveTimeout);
    autoSaveTimeout = setTimeout(async () => {
      try {
        await api.saveDraft(currentValues);
        setDraftSaved(true);
      } catch (error) {
        setDraftSaved(false);
      }
    }, 1000);
  }
});
```

**Address autocomplete:**
```tsx
const form = useForm<AddressForm>({
  onUpdateAfterBlur: async (fieldName, value, data, { setFormValues }) => {
    if (fieldName === 'zipCode' && value && value.length === 5) {
      try {
        const addressInfo = await geocodeService.getByZip(value);
        setFormValues({
          city: addressInfo.city,
          state: addressInfo.state,
          country: addressInfo.country
        });
      } catch (error) {
        // Handle geocoding error
        console.warn('Could not autocomplete address');
      }
    }
  }
});
```

**Email validation and user lookup:**
```tsx
const form = useForm<RegistrationForm>({
  onUpdateAfterBlur: async (fieldName, value, data, { setFormValues }) => {
    if (fieldName === 'email' && value) {
      // Check if user already exists
      const userExists = await api.checkEmail(value);
      if (userExists) {
        // Maybe pre-populate name if user exists
        setFormValues({ name: userExists.name });
      }
    }
  }
});
```

## Form Context Access

### `useFormContext`

Access the form instance in nested components without prop drilling.

```tsx
import { useFormContext } from 'graneet-form';

function NestedComponent() {
  const form = useFormContext<FormType>();
  
  // Use any form method
  const values = form.getFormValues();
  
  return (
    <button onClick={() => form.resetForm()}>
      Reset Form
    </button>
  );
}

// Must be used inside Form component
<Form form={form}>
  <NestedComponent />
</Form>
```

## Best Practices

### 1. Type Safety

Always provide TypeScript types for better development experience:

```tsx
interface UserForm {
  name: string;
  email: string;
  age: number;
}

const form = useForm<UserForm>(); // Fully typed
```

### 2. Error Handling in Submit

Always handle errors in your submit callback:

```tsx
const handleSubmit = form.handleSubmit(async (data) => {
  try {
    await api.saveData(data);
    // Success handling
  } catch (error) {
    // Error handling
    console.error('Save failed:', error);
  }
});
```

### 3. Conditional Field Updates

Use `onUpdateAfterBlur` for smart form behaviors:

```tsx
const form = useForm<FormData>({
  onUpdateAfterBlur: async (fieldName, value, data, { setFormValues }) => {
    // Only update related fields when specific conditions are met
    if (fieldName === 'accountType' && value === 'business') {
      setFormValues({
        taxIdRequired: true,
        businessNameRequired: true
      });
    }
  }
});
```

### 4. Performance Optimization

Avoid calling `getFormValues()` in render functions:

```tsx
// ❌ Don't do this
function FormDisplay() {
  const form = useFormContext();
  const values = form.getFormValues(); // Called on every render
  
  return <div>{JSON.stringify(values)}</div>;
}

// ✅ Do this instead
function FormDisplay() {
  const form = useFormContext();
  const values = useFieldsWatch(form, undefined); // Optimized watching
  
  return <div>{JSON.stringify(values)}</div>;
}
```