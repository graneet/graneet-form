# Advanced Features

Explore advanced patterns and techniques for building sophisticated forms with graneet-form.

## Dynamic Default Values

### Function-based Defaults

Use functions to compute default values dynamically based on external state or environment:

```tsx
interface UserProfileForm {
  name: string;
  email: string;
  theme: 'light' | 'dark';
  timezone: string;
  lastLoginDate: string;
}

function UserProfileEditor({ user }: { user?: User }) {
  const form = useForm<UserProfileForm>({
    defaultValues: () => ({
      name: user?.name || '',
      email: user?.email || '',
      theme: (localStorage.getItem('preferred-theme') as 'light' | 'dark') || 'light',
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      lastLoginDate: user?.lastLogin ? new Date(user.lastLogin).toISOString() : ''
    })
  });

  // Form automatically updates when user data changes
}
```

### Environment-based Configuration

```tsx
const form = useForm<AppConfigForm>({
  defaultValues: () => ({
    apiUrl: process.env.NODE_ENV === 'development' 
      ? 'http://localhost:3000/api' 
      : 'https://api.production.com',
    debugMode: process.env.NODE_ENV === 'development',
    featureFlags: {
      newUI: process.env.REACT_APP_ENABLE_NEW_UI === 'true',
      analytics: process.env.REACT_APP_ANALYTICS_ENABLED === 'true'
    }
  })
});
```

## Auto-save and Draft Management

### Auto-save on Field Blur

Implement automatic saving when users finish editing fields:

```tsx
interface ArticleForm {
  title: string;
  content: string;
  tags: string[];
  status: 'draft' | 'published';
}

function ArticleEditor({ articleId }: { articleId?: string }) {
  const [saveStatus, setSaveStatus] = useState<'saved' | 'saving' | 'error'>('saved');

  const form = useForm<ArticleForm>({
    onUpdateAfterBlur: async (fieldName, value, data, { getFormValues }) => {
      // Auto-save functionality
      setSaveStatus('saving');
      
      try {
        const currentValues = getFormValues();
        await api.saveDraft(articleId, currentValues);
        setSaveStatus('saved');
      } catch (error) {
        setSaveStatus('error');
        console.error('Auto-save failed:', error);
      }
    }
  });

  return (
    <div>
      <div className="save-status">
        Status: {saveStatus === 'saving' ? 'üíæ Saving...' : 
                saveStatus === 'saved' ? '‚úÖ Saved' : 
                '‚ùå Save failed'}
      </div>
      
      <Form form={form}>
        {/* Form fields */}
      </Form>
    </div>
  );
}
```

### Smart Auto-save with Debouncing

```tsx
function SmartAutoSaveForm() {
  const [lastSaved, setLastSaved] = useState<Date | null>(null);
  const saveTimeoutRef = useRef<NodeJS.Timeout>();

  const form = useForm<DocumentForm>({
    onUpdateAfterBlur: async (fieldName, value, data, { getFormValues }) => {
      // Clear any existing save timeout
      clearTimeout(saveTimeoutRef.current);
      
      // Set a new timeout to save after 2 seconds of inactivity
      saveTimeoutRef.current = setTimeout(async () => {
        try {
          const values = getFormValues();
          await api.saveDocument(values);
          setLastSaved(new Date());
        } catch (error) {
          // Handle save error
        }
      }, 2000);
    }
  });

  return (
    <div>
      {lastSaved && (
        <p>Last saved: {lastSaved.toLocaleTimeString()}</p>
      )}
      <Form form={form}>
        {/* Form fields */}
      </Form>
    </div>
  );
}
```

## Smart Field Population

### Address Autocomplete

```tsx
interface AddressForm {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}

function AddressFormWithAutocomplete() {
  const form = useForm<AddressForm>({
    onUpdateAfterBlur: async (fieldName, value, data, { setFormValues }) => {
      if (fieldName === 'zipCode' && value && value.length === 5) {
        try {
          const addressInfo = await geocodingService.getByZipCode(value);
          
          // Auto-populate city, state, and country
          setFormValues({
            city: addressInfo.city,
            state: addressInfo.state,
            country: addressInfo.country
          });
        } catch (error) {
          console.warn('Could not autocomplete address:', error);
        }
      }
    }
  });

  return (
    <Form form={form}>
      <Field<AddressForm, 'zipCode'>
        name="zipCode"
        render={(fieldProps) => (
          <input
            type="text"
            placeholder="Enter ZIP code"
            maxLength={5}
            {...fieldProps}
          />
        )}
      />
      
      <Field<AddressForm, 'city'>
        name="city"
        render={(fieldProps) => (
          <input
            type="text"
            placeholder="City (auto-populated)"
            {...fieldProps}
          />
        )}
      />
      
      {/* Other address fields */}
    </Form>
  );
}
```

### User Lookup and Pre-population

```tsx
interface RegistrationForm {
  email: string;
  firstName: string;
  lastName: string;
  company: string;
}

function RegistrationFormWithLookup() {
  const form = useForm<RegistrationForm>({
    onUpdateAfterBlur: async (fieldName, value, data, { setFormValues }) => {
      if (fieldName === 'email' && value && value.includes('@')) {
        try {
          // Check if user exists and pre-populate known information
          const existingUser = await api.getUserByEmail(value);
          
          if (existingUser) {
            setFormValues({
              firstName: existingUser.firstName,
              lastName: existingUser.lastName,
              company: existingUser.company
            });
          }
        } catch (error) {
          // User not found, continue normally
        }
      }
    }
  });

  return <Form form={form}>{/* Form fields */}</Form>;
}
```

## Conditional Form Logic

### Dynamic Field Requirements

```tsx
interface PaymentForm {
  paymentMethod: 'credit_card' | 'bank_transfer' | 'paypal';
  cardNumber?: string;
  expiryDate?: string;
  cvv?: string;
  bankAccountNumber?: string;
  routingNumber?: string;
  paypalEmail?: string;
}

function PaymentFormWithConditionalValidation() {
  const form = useFormContext<PaymentForm>();
  const { paymentMethod } = useOnChangeValues(form, ['paymentMethod']);

  return (
    <Form form={form}>
      <Field<PaymentForm, 'paymentMethod'>
        name="paymentMethod"
        render={(fieldProps) => (
          <select {...fieldProps}>
            <option value="">Select payment method</option>
            <option value="credit_card">Credit Card</option>
            <option value="bank_transfer">Bank Transfer</option>
            <option value="paypal">PayPal</option>
          </select>
        )}
      >
        <Rule
          validationFn={(value) => !!value}
          message="Please select a payment method"
        />
      </Field>

      {/* Credit Card Fields */}
      {paymentMethod === 'credit_card' && (
        <>
          <Field<PaymentForm, 'cardNumber'>
            name="cardNumber"
            render={(fieldProps) => (
              <input
                type="text"
                placeholder="Card Number"
                {...fieldProps}
              />
            )}
          >
            <Rule
              validationFn={(value) => !!value && value.length === 16}
              message="Card number must be 16 digits"
            />
          </Field>

          <Field<PaymentForm, 'expiryDate'>
            name="expiryDate"
            render={(fieldProps) => (
              <input
                type="text"
                placeholder="MM/YY"
                {...fieldProps}
              />
            )}
          >
            <Rule
              validationFn={(value) => !!value && /^\d{2}\/\d{2}$/.test(value)}
              message="Enter expiry date in MM/YY format"
            />
          </Field>
        </>
      )}

      {/* Bank Transfer Fields */}
      {paymentMethod === 'bank_transfer' && (
        <>
          <Field<PaymentForm, 'bankAccountNumber'>
            name="bankAccountNumber"
            render={(fieldProps) => (
              <input
                type="text"
                placeholder="Account Number"
                {...fieldProps}
              />
            )}
          >
            <Rule
              validationFn={(value) => !!value && value.length >= 8}
              message="Account number is required"
            />
          </Field>
        </>
      )}

      {/* PayPal Fields */}
      {paymentMethod === 'paypal' && (
        <Field<PaymentForm, 'paypalEmail'>
          name="paypalEmail"
          render={(fieldProps) => (
            <input
              type="email"
              placeholder="PayPal Email"
              {...fieldProps}
            />
          )}
        >
          <Rule
            validationFn={(value) => !!value && value.includes('@')}
            message="Valid PayPal email is required"
          />
        </Field>
      )}
    </Form>
  );
}
```

### Multi-step Forms with Conditional Logic

```tsx
interface MultiStepForm {
  userType: 'individual' | 'business';
  // Individual fields
  firstName?: string;
  lastName?: string;
  // Business fields
  companyName?: string;
  taxId?: string;
  // Common fields
  email: string;
  phone: string;
}

function MultiStepFormExample() {
  const [currentStep, setCurrentStep] = useState(1);
  const form = useForm<MultiStepForm>();
  const { userType } = useOnChangeValues(form, ['userType']);

  const renderStep = () => {
    switch (currentStep) {
      case 1:
        return (
          <div>
            <h2>Step 1: Account Type</h2>
            <Field<MultiStepForm, 'userType'>
              name="userType"
              render={(fieldProps) => (
                <div>
                  <label>
                    <input
                      type="radio"
                      value="individual"
                      checked={fieldProps.value === 'individual'}
                      onChange={() => fieldProps.onChange('individual')}
                    />
                    Individual
                  </label>
                  <label>
                    <input
                      type="radio"
                      value="business"
                      checked={fieldProps.value === 'business'}
                      onChange={() => fieldProps.onChange('business')}
                    />
                    Business
                  </label>
                </div>
              )}
            />
          </div>
        );

      case 2:
        return (
          <div>
            <h2>Step 2: Personal Information</h2>
            {userType === 'individual' ? (
              <>
                <Field<MultiStepForm, 'firstName'>
                  name="firstName"
                  render={(fieldProps) => (
                    <input placeholder="First Name" {...fieldProps} />
                  )}
                />
                <Field<MultiStepForm, 'lastName'>
                  name="lastName"
                  render={(fieldProps) => (
                    <input placeholder="Last Name" {...fieldProps} />
                  )}
                />
              </>
            ) : (
              <>
                <Field<MultiStepForm, 'companyName'>
                  name="companyName"
                  render={(fieldProps) => (
                    <input placeholder="Company Name" {...fieldProps} />
                  )}
                />
                <Field<MultiStepForm, 'taxId'>
                  name="taxId"
                  render={(fieldProps) => (
                    <input placeholder="Tax ID" {...fieldProps} />
                  )}
                />
              </>
            )}
          </div>
        );

      case 3:
        return (
          <div>
            <h2>Step 3: Contact Information</h2>
            <Field<MultiStepForm, 'email'>
              name="email"
              render={(fieldProps) => (
                <input type="email" placeholder="Email" {...fieldProps} />
              )}
            />
            <Field<MultiStepForm, 'phone'>
              name="phone"
              render={(fieldProps) => (
                <input type="tel" placeholder="Phone" {...fieldProps} />
              )}
            />
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <Form form={form}>
      {renderStep()}
      
      <div className="form-navigation">
        {currentStep > 1 && (
          <button onClick={() => setCurrentStep(currentStep - 1)}>
            Previous
          </button>
        )}
        {currentStep < 3 ? (
          <button onClick={() => setCurrentStep(currentStep + 1)}>
            Next
          </button>
        ) : (
          <button type="submit">Submit</button>
        )}
      </div>
    </Form>
  );
}
```

## Real-time Calculations

### Dynamic Pricing Calculator

```tsx
interface OrderForm {
  quantity: number;
  productPrice: number;
  discountCode?: string;
  shippingMethod: 'standard' | 'express';
  taxRate: number;
}

function OrderFormWithCalculations() {
  const form = useFormContext<OrderForm>();
  
  // Watch relevant fields for calculations
  const { quantity, productPrice, discountCode, shippingMethod, taxRate } = 
    useOnChangeValues(form, ['quantity', 'productPrice', 'discountCode', 'shippingMethod', 'taxRate']);

  // Calculate totals in real-time
  const calculations = useMemo(() => {
    const subtotal = (quantity || 0) * (productPrice || 0);
    
    let discount = 0;
    if (discountCode === 'SAVE10') discount = subtotal * 0.1;
    if (discountCode === 'SAVE20') discount = subtotal * 0.2;
    
    const shipping = shippingMethod === 'express' ? 15 : 5;
    const taxAmount = (subtotal - discount + shipping) * ((taxRate || 0) / 100);
    const total = subtotal - discount + shipping + taxAmount;

    return { subtotal, discount, shipping, taxAmount, total };
  }, [quantity, productPrice, discountCode, shippingMethod, taxRate]);

  return (
    <div>
      <Form form={form}>
        <Field<OrderForm, 'quantity'>
          name="quantity"
          defaultValue={1}
          render={(fieldProps) => (
            <input
              type="number"
              min="1"
              placeholder="Quantity"
              {...fieldProps}
            />
          )}
        />

        <Field<OrderForm, 'productPrice'>
          name="productPrice"
          defaultValue={29.99}
          render={(fieldProps) => (
            <input
              type="number"
              step="0.01"
              placeholder="Product Price"
              {...fieldProps}
            />
          )}
        />

        <Field<OrderForm, 'discountCode'>
          name="discountCode"
          render={(fieldProps) => (
            <input
              type="text"
              placeholder="Discount Code (SAVE10, SAVE20)"
              {...fieldProps}
            />
          )}
        />

        <Field<OrderForm, 'shippingMethod'>
          name="shippingMethod"
          defaultValue="standard"
          render={(fieldProps) => (
            <select {...fieldProps}>
              <option value="standard">Standard Shipping ($5)</option>
              <option value="express">Express Shipping ($15)</option>
            </select>
          )}
        />
      </Form>

      {/* Real-time calculation display */}
      <div className="order-summary">
        <h3>Order Summary</h3>
        <div>Subtotal: ${calculations.subtotal.toFixed(2)}</div>
        {calculations.discount > 0 && (
          <div>Discount: -${calculations.discount.toFixed(2)}</div>
        )}
        <div>Shipping: ${calculations.shipping.toFixed(2)}</div>
        <div>Tax: ${calculations.taxAmount.toFixed(2)}</div>
        <div className="total">
          <strong>Total: ${calculations.total.toFixed(2)}</strong>
        </div>
      </div>
    </div>
  );
}
```

## Form Analytics and Tracking

### Field Interaction Analytics

```tsx
interface FormAnalytics {
  fieldInteractions: Record<string, {
    focusCount: number;
    timeSpent: number;
    lastInteraction: Date;
  }>;
  formStartTime: Date;
  formEndTime?: Date;
}

function useFormAnalytics<T extends FieldValues>() {
  const [analytics, setAnalytics] = useState<FormAnalytics>({
    fieldInteractions: {},
    formStartTime: new Date()
  });

  const trackFieldFocus = useCallback((fieldName: keyof T) => {
    setAnalytics(prev => ({
      ...prev,
      fieldInteractions: {
        ...prev.fieldInteractions,
        [fieldName]: {
          focusCount: (prev.fieldInteractions[fieldName]?.focusCount || 0) + 1,
          timeSpent: prev.fieldInteractions[fieldName]?.timeSpent || 0,
          lastInteraction: new Date()
        }
      }
    }));
  }, []);

  const trackFieldBlur = useCallback((fieldName: keyof T, focusTime: Date) => {
    const timeSpent = Date.now() - focusTime.getTime();
    
    setAnalytics(prev => ({
      ...prev,
      fieldInteractions: {
        ...prev.fieldInteractions,
        [fieldName]: {
          ...prev.fieldInteractions[fieldName],
          timeSpent: (prev.fieldInteractions[fieldName]?.timeSpent || 0) + timeSpent
        }
      }
    }));
  }, []);

  const trackFormCompletion = useCallback(() => {
    setAnalytics(prev => ({
      ...prev,
      formEndTime: new Date()
    }));
  }, []);

  return {
    analytics,
    trackFieldFocus,
    trackFieldBlur,
    trackFormCompletion
  };
}

// Usage in a field component
function AnalyticsEnabledField<T extends FieldValues, K extends keyof T>({
  name,
  ...props
}: FieldProps<T, K>) {
  const [focusTime, setFocusTime] = useState<Date>();
  const { trackFieldFocus, trackFieldBlur } = useFormAnalytics<T>();

  return (
    <Field<T, K>
      name={name}
      render={(fieldProps, fieldState) => (
        <input
          {...fieldProps}
          onFocus={() => {
            fieldProps.onFocus();
            setFocusTime(new Date());
            trackFieldFocus(name);
          }}
          onBlur={() => {
            fieldProps.onBlur();
            if (focusTime) {
              trackFieldBlur(name, focusTime);
            }
          }}
        />
      )}
      {...props}
    />
  );
}
```

## Performance Optimizations

### Lazy Field Registration

```tsx
interface LargeFormData {
  // Hundreds of potential fields
  [key: string]: any;
}

function LazyLoadedForm() {
  const [visibleSections, setVisibleSections] = useState<Set<string>>(new Set(['basic']));
  const form = useForm<LargeFormData>();

  const showSection = (sectionName: string) => {
    setVisibleSections(prev => new Set([...prev, sectionName]));
  };

  return (
    <Form form={form}>
      {/* Always visible basic fields */}
      <BasicInfoSection />
      
      {/* Conditionally rendered sections */}
      {visibleSections.has('address') && <AddressSection />}
      {visibleSections.has('payment') && <PaymentSection />}
      {visibleSections.has('preferences') && <PreferencesSection />}
      
      {/* Show/hide section buttons */}
      <div className="section-controls">
        {!visibleSections.has('address') && (
          <button onClick={() => showSection('address')}>
            Add Address Information
          </button>
        )}
        {!visibleSections.has('payment') && (
          <button onClick={() => showSection('payment')}>
            Add Payment Information
          </button>
        )}
        {!visibleSections.has('preferences') && (
          <button onClick={() => showSection('preferences')}>
            Add Preferences
          </button>
        )}
      </div>
    </Form>
  );
}
```

### Optimized Watching Patterns

```tsx
// Custom hook for optimized form watching
function useOptimizedFormWatcher<T extends FieldValues>(
  form: FormContextApi<T>,
  criticalFields: (keyof T)[],
  nonCriticalFields: (keyof T)[]
) {
  // Critical fields update immediately
  const criticalValues = useOnChangeValues(form, criticalFields);
  
  // Non-critical fields update on blur only
  const nonCriticalValues = useOnBlurValues(form, nonCriticalFields);
  
  return useMemo(() => ({
    ...criticalValues,
    ...nonCriticalValues
  }), [criticalValues, nonCriticalValues]);
}

// Usage
function OptimizedFormWatcher() {
  const form = useFormContext<LargeFormData>();
  
  const values = useOptimizedFormWatcher(
    form,
    ['searchQuery', 'liveFilter'], // Critical: need immediate updates
    ['description', 'notes', 'metadata'] // Non-critical: blur updates are fine
  );
  
  return <div>/* Use values */</div>;
}
```

## Integration Patterns

### Redux/Zustand Integration

```tsx
// Zustand store
interface FormStore {
  formData: Partial<UserForm>;
  updateFormData: (data: Partial<UserForm>) => void;
  resetFormData: () => void;
}

const useFormStore = create<FormStore>((set) => ({
  formData: {},
  updateFormData: (data) => set((state) => ({
    formData: { ...state.formData, ...data }
  })),
  resetFormData: () => set({ formData: {} })
}));

// Integration component
function StoreIntegratedForm() {
  const { formData, updateFormData, resetFormData } = useFormStore();
  
  const form = useForm<UserForm>({
    defaultValues: () => formData,
    onUpdateAfterBlur: async (fieldName, value) => {
      // Sync to store on every valid field update
      updateFormData({ [fieldName]: value });
    }
  });

  const handleSubmit = form.handleSubmit(async (data) => {
    await api.saveUser(data);
    resetFormData();
  });

  return (
    <form onSubmit={handleSubmit}>
      <Form form={form}>
        {/* Form fields */}
      </Form>
    </form>
  );
}
```

## Next Steps

- [Field Management Guide](./field-management) - Deep dive into field handling
- [Performance Optimization](./performance) - Optimize large and complex forms
- [TypeScript Guide](./typescript-guide) - Advanced TypeScript patterns